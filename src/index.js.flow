// @flow

/**
 * Reads & checks an untrusted value. Throws an exception if it's wrong.
 */
export type Cleaner<T> = (raw: any) => T

/**
 * A cleaner, but with an extra `shape` property:
 */
export type ObjectCleaner<T> = Cleaner<T> & {
  +shape: $ObjMap<T, <T>(type: T) => Cleaner<T>>
}

// simple types --------------------------------------------------------------

declare export var asBoolean: Cleaner<boolean>
declare export var asDate: Cleaner<Date>
declare export var asNone: Cleaner<void>
declare export var asNull: Cleaner<null>
declare export var asNumber: Cleaner<number>
declare export var asString: Cleaner<string>
declare export var asUndefined: Cleaner<void>
declare export var asUnknown: Cleaner<mixed>

// nested types ----------------------------------------------------------------

type ReturnType = <T>(f: () => T) => T

/**
 * Makes a cleaner that accepts an array with the given item type.
 */
declare export function asArray<T>(cleaner: Cleaner<T>): Cleaner<T[]>

/**
 * Makes a cleaner that accepts an object with arbitrary keys
 * and the given value type. Removes keys named `__proto__` for safety.
 */
declare export function asMap<T>(
  cleaner: Cleaner<T>
): Cleaner<{ [key: string]: T }>

/**
 * Makes a cleaner that accepts an object with the given property types.
 */
declare export function asObject<Shape>(
  shape: Shape
): ObjectCleaner<$ObjMap<Shape, ReturnType>>

/**
 * Unpacks a value that may be void or null,
 * returning a fallback value (or `undefined`) if missing.
 */
declare export var asOptional: {|
  <T>(cleaner: Cleaner<T>): Cleaner<T | void>,
  <T>(cleaner: Cleaner<T>, fallback: $Call<Cleaner<T>>): Cleaner<T>
|}

/**
 * Makes a cleaner that accepts either of the given types.
 */
declare export function asEither<A, B>(
  a: Cleaner<A>,
  b: Cleaner<B>
): Cleaner<A | B>

/**
 * Wraps a cleaner with an error handling,
 * returning a fallback value (or `undefined`) if the cleaner throws.
 */
declare export var asMaybe: {|
  <T>(cleaner: Cleaner<T>): Cleaner<T | void>,
  <T>(cleaner: Cleaner<T>, fallback: $Call<Cleaner<T>>): Cleaner<T>
|}

/**
 * Makes a cleaner that parses & validates JSON strings.
 */
declare export function asJSON<T>(cleaner: Cleaner<T>): Cleaner<T>
