// @flow

/**
 * Reads & checks an untrusted value. Throws an exception if it's wrong.
 */
export type Cleaner<T> = (raw: any) => T

// simple types --------------------------------------------------------------

declare export var asBoolean: Cleaner<boolean>
declare export var asDate: Cleaner<Date>
declare export var asNumber: Cleaner<number>
declare export var asString: Cleaner<string>
declare export var asNone: Cleaner<void>
declare export var asNull: Cleaner<null>
declare export var asUndefined: Cleaner<void>
declare export var asUnknown: Cleaner<mixed>

// nested types ----------------------------------------------------------------

type ObjectCleaner<Shape> = Cleaner<
  $ObjMap<Shape, <T>(cleaner: () => T) => T>
> & {
  +shape: Shape
}

/**
 * Makes a cleaner that accepts an array with the given item type.
 */
declare export function asArray<T>(cleaner: (raw: any) => T): Cleaner<T[]>

/**
 * Makes a cleaner that accepts an object with arbitrary keys
 * and the given value type. Removes keys named `__proto__` for safety.
 */
declare export function asMap<T>(
  cleaner: (raw: any) => T
): Cleaner<{ [key: string]: T }>

/**
 * Makes a cleaner that accepts an object with the given property types.
 */
declare export function asObject<Shape: { [key: string]: Function }>(
  shape: Shape
): ObjectCleaner<$Diff<$Exact<Shape>, {||}>> // Dummy Diff to help exports work

/**
 * Unpacks a value that may be void or null,
 * returning a fallback value if missing.
 */
declare export function asOptional<T, U>(
  cleaner: (raw: any) => T,
  fallback: U
): Cleaner<T | U>

/**
 * Makes a cleaner that accepts either of the given types.
 */
declare export function asEither<A, B>(
  a: (raw: any) => A,
  b: (raw: any) => B
): Cleaner<A | B>

/**
 * Makes a cleaner that parses & validates JSON strings.
 */
declare export function asJSON<T>(cleaner: Cleaner<T>): Cleaner<T>
